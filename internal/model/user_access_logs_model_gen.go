// Code generated by pgmodelgen. DO NOT EDIT.
// generated_at_utc: 2026-01-01T08:00:00Z
// version: 0.1.0

package model

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
	"strings"
	"time"
)

var (
	userAccessLogsFieldNames        = builder.RawFieldNames(&UserAccessLogs{}, true)
	userAccessLogsRows              = strings.Join(userAccessLogsFieldNames, ",")
	userAccessLogsRowsExpectAutoSet = strings.Join(stringx.Remove(userAccessLogsFieldNames, "id"), ",")
)

type (
	userAccessLogsModel interface {
		Insert(ctx context.Context, data *UserAccessLogs) (sql.Result, error)
		InsertReturn(ctx context.Context, session sqlx.Session, data *UserAccessLogs) (*UserAccessLogs, error)
		BatchInsertReturn(ctx context.Context, session sqlx.Session, dataList []*UserAccessLogs) ([]*UserAccessLogs, error)
		FindOne(ctx context.Context, id int64) (*UserAccessLogs, error)
		Update(ctx context.Context, data *UserAccessLogs) error
		Delete(ctx context.Context, id int64) error
	}

	defaultUserAccessLogsModel struct {
		conn  sqlx.SqlConn
		table string
	}

	UserAccessLogs struct {
		Id        int64     `db:"id"`         // 流水 ID
		UserId    int64     `db:"user_id"`    // 用户 ID
		IpAddress string    `db:"ip_address"` // IP 地址
		UserAgent string    `db:"user_agent"` // User-Agent
		Action    string    `db:"action"`     // 行为类型 [ENUM: LOGIN, LOGOUT, MFA_CHALLENGE, MFA_VERIFY, SESSION_REVOKED]
		Status    string    `db:"status"`     // 状态 [ENUM: SUCCESS, FAIL, BLOCKED]
		Reason    string    `db:"reason"`     // 原因
		Details   string    `db:"details"`    // 扩展信息 [JSON]
		CreatedAt time.Time `db:"created_at"` // 记录时间
	}
)

func newUserAccessLogsModel(conn sqlx.SqlConn) *defaultUserAccessLogsModel {
	return &defaultUserAccessLogsModel{
		conn:  conn,
		table: "\"public\".\"user_access_logs\"",
	}
}

func (m *defaultUserAccessLogsModel) Delete(ctx context.Context, id int64) error {
	query := fmt.Sprintf("delete from %s where id = $1", m.table)
	_, err := m.conn.ExecCtx(ctx, query, id)
	return err
}

func (m *defaultUserAccessLogsModel) FindOne(ctx context.Context, id int64) (*UserAccessLogs, error) {
	query := fmt.Sprintf("select %s from %s where id = $1 limit 1", userAccessLogsRows, m.table)
	var resp UserAccessLogs
	err := m.conn.QueryRowCtx(ctx, &resp, query, id)
	if err != nil {
		return nil, err
	}
	return &resp, nil
}

func (m *defaultUserAccessLogsModel) Insert(ctx context.Context, data *UserAccessLogs) (sql.Result, error) {
	builder := m.insertBuilder().Columns(userAccessLogsRowsExpectAutoSet).Values(data.UserId, data.IpAddress, data.UserAgent, data.Action, data.Status, data.Reason, data.Details, data.CreatedAt)
	querySql, values, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	return m.conn.ExecCtx(ctx, querySql, values...)
}

func (m *defaultUserAccessLogsModel) BatchInsertReturn(ctx context.Context, session sqlx.Session, dataList []*UserAccessLogs) ([]*UserAccessLogs, error) {
	builder := m.insertBuilder().Columns(userAccessLogsRowsExpectAutoSet)
	for _, data := range dataList {
		builder = builder.Values(data.UserId, data.IpAddress, data.UserAgent, data.Action, data.Status, data.Reason, data.Details, data.CreatedAt)
	}
	return m.insertListWithReturn(ctx, session, builder)
}

func (m *defaultUserAccessLogsModel) InsertReturn(ctx context.Context, session sqlx.Session, data *UserAccessLogs) (*UserAccessLogs, error) {
	builder := m.insertBuilder().Columns(userAccessLogsRowsExpectAutoSet).Values(data.UserId, data.IpAddress, data.UserAgent, data.Action, data.Status, data.Reason, data.Details, data.CreatedAt)
	return m.insertWithReturn(ctx, session, builder)
}

func (m *defaultUserAccessLogsModel) Update(ctx context.Context, newData *UserAccessLogs) error {
	builder := m.updateBuilder()
	builder = builder.Set("user_id", newData.UserId)
	builder = builder.Set("ip_address", newData.IpAddress)
	builder = builder.Set("user_agent", newData.UserAgent)
	builder = builder.Set("action", newData.Action)
	builder = builder.Set("status", newData.Status)
	builder = builder.Set("reason", newData.Reason)
	builder = builder.Set("details", newData.Details)
	builder = builder.Set("created_at", newData.CreatedAt)
	builder = builder.Where(squirrel.Eq{
		"id": newData.Id,
	})
	return m.execCtxWithSession(ctx, nil, builder)
}

func (m *defaultUserAccessLogsModel) tableName() string {
	return m.table
}

func (m *defaultUserAccessLogsModel) selectBuilder() squirrel.SelectBuilder {
	return squirrel.Select().PlaceholderFormat(squirrel.Dollar).From(m.table)
}

func (m *defaultUserAccessLogsModel) insertBuilder() squirrel.InsertBuilder {
	return squirrel.Insert(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *defaultUserAccessLogsModel) replaceBuilder() squirrel.InsertBuilder {
	return squirrel.Replace(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *defaultUserAccessLogsModel) updateBuilder() squirrel.UpdateBuilder {
	return squirrel.Update(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *defaultUserAccessLogsModel) deleteBuilder() squirrel.DeleteBuilder {
	return squirrel.Delete(m.table).PlaceholderFormat(squirrel.Dollar)
}

func (m *defaultUserAccessLogsModel) execCtxWithSession(ctx context.Context, session sqlx.Session, sqlizer squirrel.Sqlizer) error {
	sqlStr, args, err := sqlizer.ToSql()
	if err != nil {
		return err
	}
	if session != nil {
		_, err = session.Exec(sqlStr, args...)
	} else {
		_, err = m.conn.ExecCtx(ctx, sqlStr, args...)
	}
	return err
}

func (m *defaultUserAccessLogsModel) insertListWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.InsertBuilder) ([]*UserAccessLogs, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING *").ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*UserAccessLogs
	if session != nil {
		err = session.QueryRowsCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	}
	return resp, err
}

func (m *defaultUserAccessLogsModel) insertWithReturn(ctx context.Context, session sqlx.Session, sqlizer squirrel.InsertBuilder) (*UserAccessLogs, error) {
	querySql, values, err := sqlizer.Suffix("RETURNING *").ToSql()
	if err != nil {
		return nil, err
	}
	var resp UserAccessLogs
	if session != nil {
		err = session.QueryRowCtx(ctx, &resp, querySql, values...)
	} else {
		err = m.conn.QueryRowCtx(ctx, &resp, querySql, values...)
	}
	return &resp, err
}

func (m *defaultUserAccessLogsModel) findCount(ctx context.Context, builder squirrel.SelectBuilder) (int64, error) {
	builder = builder.Columns("COUNT(" + m.tableName() + ".id)")
	query, values, err := builder.ToSql()
	if err != nil {
		return 0, err
	}
	var resp int64
	err = m.conn.QueryRowCtx(ctx, &resp, query, values...)
	if err != nil {
		return 0, err
	}
	return resp, nil
}

func (m *defaultUserAccessLogsModel) findList(ctx context.Context, builder squirrel.SelectBuilder) ([]*UserAccessLogs, error) {
	builder = builder.Columns(m.tableName() + ".*")
	querySql, values, err := builder.ToSql()
	if err != nil {
		return nil, err
	}
	var resp []*UserAccessLogs
	err = m.conn.QueryRowsCtx(ctx, &resp, querySql, values...)
	return resp, err
}

