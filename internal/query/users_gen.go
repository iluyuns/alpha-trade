// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T18:09:36Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// Users represents a row in table "public"."users".
//
// Indexes:
//   - users_pkey (PRIMARY KEY) (btree): id
//   - users_github_id_key (UNIQUE) (btree): github_id
//   - users_google_id_key (UNIQUE) (btree): google_id
//   - users_username_key (UNIQUE) (btree): username
//   - users_uuid_key (UNIQUE) (btree): uuid
type Users struct {
	ID              int64     `db:"id" json:"id"`                               // 内部自增主键
	Uuid            string    `db:"uuid" json:"uuid"`                           // WebAuthn User Handle (UUID)
	Username        string    `db:"username" json:"username"`                   // 登录用户名
	DisplayName     string    `db:"display_name" json:"display_name"`           // 用户显示名称
	Avatar          string    `db:"avatar" json:"avatar"`                       // 用户头像 URL
	PasswordHash    string    `db:"password_hash" json:"password_hash"`         // 静态密码哈希：仅用于 Break-Glass 紧急恢复 (Argon2id)
	IsActive        bool      `db:"is_active" json:"is_active"`                 // 账号激活状态
	CreatedAt       time.Time `db:"created_at" json:"created_at"`               // 账号创建时间
	UpdatedAt       time.Time `db:"updated_at" json:"updated_at"`               // 最后更新时间
	RevokedAt       time.Time `db:"revoked_at" json:"revoked_at"`               // 令牌撤销基准时间：早于此时间的 Token 视为无效
	GithubID        string    `db:"github_id" json:"github_id"`                 // GitHub 唯一标识 (ID)
	GoogleID        string    `db:"google_id" json:"google_id"`                 // Google 唯一标识 (Sub)
	TotpSecret      string    `db:"totp_secret" json:"totp_secret"`             // 加密存储的 TOTP 密钥 (AES-256-GCM)
	TotpEnabled     bool      `db:"totp_enabled" json:"totp_enabled"`           // 是否启用了 TOTP 二步验证
	TotpBackupCodes string    `db:"totp_backup_codes" json:"totp_backup_codes"` // TOTP 备份恢复码 (加密存储的数组)
}

// TableName returns the table name for Users
func (m *Users) TableName() string {
	return "public.users"
}

// UsersIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type UsersIndex struct {
	ID       int64  `db:"id" json:"id"`               // 内部自增主键
	Uuid     string `db:"uuid" json:"uuid"`           // WebAuthn User Handle (UUID)
	Username string `db:"username" json:"username"`   // 登录用户名
	GithubID string `db:"github_id" json:"github_id"` // GitHub 唯一标识 (ID)
	GoogleID string `db:"google_id" json:"google_id"` // Google 唯一标识 (Sub)
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *usersDo) Create(ctx context.Context, model *Users) (*Users, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("uuid", "username", "display_name", "avatar", "password_hash", "is_active", "created_at", "updated_at", "revoked_at", "github_id", "google_id", "totp_secret", "totp_enabled", "totp_backup_codes").
		Values(model.Uuid, model.Username, model.DisplayName, model.Avatar, model.PasswordHash, model.IsActive, model.CreatedAt, model.UpdatedAt, model.RevokedAt, model.GithubID, model.GoogleID, model.TotpSecret, model.TotpEnabled, model.TotpBackupCodes).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result Users
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *usersDo) BatchCreate(ctx context.Context, models []*Users) ([]*Users, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("uuid", "username", "display_name", "avatar", "password_hash", "is_active", "created_at", "updated_at", "revoked_at", "github_id", "google_id", "totp_secret", "totp_enabled", "totp_backup_codes")

	for _, model := range models {
		builder = builder.Values(model.Uuid, model.Username, model.DisplayName, model.Avatar, model.PasswordHash, model.IsActive, model.CreatedAt, model.UpdatedAt, model.RevokedAt, model.GithubID, model.GoogleID, model.TotpSecret, model.TotpEnabled, model.TotpBackupCodes)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*Users
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *usersDo) FindByPK(ctx context.Context, iD int64) (*Users, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result Users
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *usersDo) UpdateByPK(ctx context.Context, model *Users) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("uuid", model.Uuid)
	builder = builder.Set("username", model.Username)
	builder = builder.Set("display_name", model.DisplayName)
	builder = builder.Set("avatar", model.Avatar)
	builder = builder.Set("password_hash", model.PasswordHash)
	builder = builder.Set("is_active", model.IsActive)
	builder = builder.Set("updated_at", model.UpdatedAt)
	builder = builder.Set("revoked_at", model.RevokedAt)
	builder = builder.Set("github_id", model.GithubID)
	builder = builder.Set("google_id", model.GoogleID)
	builder = builder.Set("totp_secret", model.TotpSecret)
	builder = builder.Set("totp_enabled", model.TotpEnabled)
	builder = builder.Set("totp_backup_codes", model.TotpBackupCodes)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *usersDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *usersDo) Upsert(ctx context.Context, model *Users) (*Users, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("uuid", "username", "display_name", "avatar", "password_hash", "is_active", "created_at", "updated_at", "revoked_at", "github_id", "google_id", "totp_secret", "totp_enabled", "totp_backup_codes").
		Values(model.Uuid, model.Username, model.DisplayName, model.Avatar, model.PasswordHash, model.IsActive, model.CreatedAt, model.UpdatedAt, model.RevokedAt, model.GithubID, model.GoogleID, model.TotpSecret, model.TotpEnabled, model.TotpBackupCodes)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "uuid = CASE WHEN EXCLUDED.uuid = '' THEN users.uuid ELSE EXCLUDED.uuid END"
	updateClause += ", "
	updateClause += "username = CASE WHEN EXCLUDED.username = '' THEN users.username ELSE EXCLUDED.username END"
	updateClause += ", "
	updateClause += "display_name = CASE WHEN EXCLUDED.display_name = '' THEN users.display_name ELSE EXCLUDED.display_name END"
	updateClause += ", "
	updateClause += "avatar = CASE WHEN EXCLUDED.avatar = '' THEN users.avatar ELSE EXCLUDED.avatar END"
	updateClause += ", "
	updateClause += "password_hash = CASE WHEN EXCLUDED.password_hash = '' THEN users.password_hash ELSE EXCLUDED.password_hash END"
	updateClause += ", "
	updateClause += "is_active = EXCLUDED.is_active"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"
	updateClause += ", "
	updateClause += "revoked_at = EXCLUDED.revoked_at"
	updateClause += ", "
	updateClause += "github_id = CASE WHEN EXCLUDED.github_id = '' THEN users.github_id ELSE EXCLUDED.github_id END"
	updateClause += ", "
	updateClause += "google_id = CASE WHEN EXCLUDED.google_id = '' THEN users.google_id ELSE EXCLUDED.google_id END"
	updateClause += ", "
	updateClause += "totp_secret = CASE WHEN EXCLUDED.totp_secret = '' THEN users.totp_secret ELSE EXCLUDED.totp_secret END"
	updateClause += ", "
	updateClause += "totp_enabled = EXCLUDED.totp_enabled"
	updateClause += ", "
	updateClause += "totp_backup_codes = CASE WHEN EXCLUDED.totp_backup_codes = '' THEN users.totp_backup_codes ELSE EXCLUDED.totp_backup_codes END"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result Users
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *usersDo) UpsertAll(ctx context.Context, model *Users) (*Users, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("uuid", "username", "display_name", "avatar", "password_hash", "is_active", "created_at", "updated_at", "revoked_at", "github_id", "google_id", "totp_secret", "totp_enabled", "totp_backup_codes").
		Values(model.Uuid, model.Username, model.DisplayName, model.Avatar, model.PasswordHash, model.IsActive, model.CreatedAt, model.UpdatedAt, model.RevokedAt, model.GithubID, model.GoogleID, model.TotpSecret, model.TotpEnabled, model.TotpBackupCodes)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "uuid = EXCLUDED.uuid"
	updateClause += ", "
	updateClause += "username = EXCLUDED.username"
	updateClause += ", "
	updateClause += "display_name = EXCLUDED.display_name"
	updateClause += ", "
	updateClause += "avatar = EXCLUDED.avatar"
	updateClause += ", "
	updateClause += "password_hash = EXCLUDED.password_hash"
	updateClause += ", "
	updateClause += "is_active = EXCLUDED.is_active"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"
	updateClause += ", "
	updateClause += "revoked_at = EXCLUDED.revoked_at"
	updateClause += ", "
	updateClause += "github_id = EXCLUDED.github_id"
	updateClause += ", "
	updateClause += "google_id = EXCLUDED.google_id"
	updateClause += ", "
	updateClause += "totp_secret = EXCLUDED.totp_secret"
	updateClause += ", "
	updateClause += "totp_enabled = EXCLUDED.totp_enabled"
	updateClause += ", "
	updateClause += "totp_backup_codes = EXCLUDED.totp_backup_codes"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result Users
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *usersDo) FindByIndex(ctx context.Context, req *UsersIndex) ([]*UsersIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}
	if req.Uuid != "" {
		builder = builder.Where(squirrel.Eq{"uuid": req.Uuid})
	}
	if req.Username != "" {
		builder = builder.Where(squirrel.Eq{"username": req.Username})
	}
	if req.GithubID != "" {
		builder = builder.Where(squirrel.Eq{"github_id": req.GithubID})
	}
	if req.GoogleID != "" {
		builder = builder.Where(squirrel.Eq{"google_id": req.GoogleID})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id", "uuid", "username", "github_id", "google_id")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*UsersIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
