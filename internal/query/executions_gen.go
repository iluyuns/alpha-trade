// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T17:23:17Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/shopspring/decimal"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// Executions represents a row in table "public"."executions".
//
// Indexes:
//   - executions_pkey (PRIMARY KEY) (btree): id
//   - executions_exec_id_symbol_key (UNIQUE) (btree): exec_id, symbol
//   - idx_executions_client_oid (btree): client_oid
type Executions struct {
	ID        int64           `db:"id" json:"id"`                 // 流水 ID
	OrderID   int64           `db:"order_id" json:"order_id"`     // 关联的本地 Orders ID
	ClientOid string          `db:"client_oid" json:"client_oid"` // 关联的本地 ClientOid
	ExecID    string          `db:"exec_id" json:"exec_id"`       // 交易所成交 ID (Trade ID)
	Symbol    string          `db:"symbol" json:"symbol"`         // 交易对
	Side      string          `db:"side" json:"side"`             // 成交方向 [ENUM: BUY, SELL]
	Price     decimal.Decimal `db:"price" json:"price"`           // 成交价格
	Quantity  decimal.Decimal `db:"quantity" json:"quantity"`     // 成交数量
	QuoteQty  decimal.Decimal `db:"quote_qty" json:"quote_qty"`   // 成交金额 (Quote Asset)
	Fee       decimal.Decimal `db:"fee" json:"fee"`               // 手续费数值
	FeeAsset  string          `db:"fee_asset" json:"fee_asset"`   // 手续费计价币种
	TradedAt  time.Time       `db:"traded_at" json:"traded_at"`   // 交易所成交撮合时间
	CreatedAt time.Time       `db:"created_at" json:"created_at"` // 记录存库时间
}

// TableName returns the table name for Executions
func (m *Executions) TableName() string {
	return "public.executions"
}

// ExecutionsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type ExecutionsIndex struct {
	ID        int64  `db:"id" json:"id"`                 // 流水 ID
	ClientOid string `db:"client_oid" json:"client_oid"` // 关联的本地 ClientOid
	ExecID    string `db:"exec_id" json:"exec_id"`       // 交易所成交 ID (Trade ID)
	Symbol    string `db:"symbol" json:"symbol"`         // 交易对
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *executionsDo) Create(ctx context.Context, model *Executions) (*Executions, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exec_id", "symbol", "side", "price", "quantity", "quote_qty", "fee", "fee_asset", "traded_at", "created_at").
		Values(model.OrderID, model.ClientOid, model.ExecID, model.Symbol, model.Side, model.Price, model.Quantity, model.QuoteQty, model.Fee, model.FeeAsset, model.TradedAt, model.CreatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result Executions
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *executionsDo) BatchCreate(ctx context.Context, models []*Executions) ([]*Executions, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exec_id", "symbol", "side", "price", "quantity", "quote_qty", "fee", "fee_asset", "traded_at", "created_at")

	for _, model := range models {
		builder = builder.Values(model.OrderID, model.ClientOid, model.ExecID, model.Symbol, model.Side, model.Price, model.Quantity, model.QuoteQty, model.Fee, model.FeeAsset, model.TradedAt, model.CreatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*Executions
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *executionsDo) FindByPK(ctx context.Context, iD int64) (*Executions, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result Executions
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *executionsDo) UpdateByPK(ctx context.Context, model *Executions) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("order_id", model.OrderID)
	builder = builder.Set("client_oid", model.ClientOid)
	builder = builder.Set("exec_id", model.ExecID)
	builder = builder.Set("symbol", model.Symbol)
	builder = builder.Set("side", model.Side)
	builder = builder.Set("price", model.Price)
	builder = builder.Set("quantity", model.Quantity)
	builder = builder.Set("quote_qty", model.QuoteQty)
	builder = builder.Set("fee", model.Fee)
	builder = builder.Set("fee_asset", model.FeeAsset)
	builder = builder.Set("traded_at", model.TradedAt)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *executionsDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *executionsDo) Upsert(ctx context.Context, model *Executions) (*Executions, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exec_id", "symbol", "side", "price", "quantity", "quote_qty", "fee", "fee_asset", "traded_at", "created_at").
		Values(model.OrderID, model.ClientOid, model.ExecID, model.Symbol, model.Side, model.Price, model.Quantity, model.QuoteQty, model.Fee, model.FeeAsset, model.TradedAt, model.CreatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "order_id = CASE WHEN EXCLUDED.order_id = 0 THEN executions.order_id ELSE EXCLUDED.order_id END"
	updateClause += ", "
	updateClause += "client_oid = CASE WHEN EXCLUDED.client_oid = '' THEN executions.client_oid ELSE EXCLUDED.client_oid END"
	updateClause += ", "
	updateClause += "exec_id = CASE WHEN EXCLUDED.exec_id = '' THEN executions.exec_id ELSE EXCLUDED.exec_id END"
	updateClause += ", "
	updateClause += "symbol = CASE WHEN EXCLUDED.symbol = '' THEN executions.symbol ELSE EXCLUDED.symbol END"
	updateClause += ", "
	updateClause += "side = CASE WHEN EXCLUDED.side = '' THEN executions.side ELSE EXCLUDED.side END"
	updateClause += ", "
	updateClause += "price = EXCLUDED.price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "quote_qty = EXCLUDED.quote_qty"
	updateClause += ", "
	updateClause += "fee = EXCLUDED.fee"
	updateClause += ", "
	updateClause += "fee_asset = CASE WHEN EXCLUDED.fee_asset = '' THEN executions.fee_asset ELSE EXCLUDED.fee_asset END"
	updateClause += ", "
	updateClause += "traded_at = EXCLUDED.traded_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result Executions
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *executionsDo) UpsertAll(ctx context.Context, model *Executions) (*Executions, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exec_id", "symbol", "side", "price", "quantity", "quote_qty", "fee", "fee_asset", "traded_at", "created_at").
		Values(model.OrderID, model.ClientOid, model.ExecID, model.Symbol, model.Side, model.Price, model.Quantity, model.QuoteQty, model.Fee, model.FeeAsset, model.TradedAt, model.CreatedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "order_id = EXCLUDED.order_id"
	updateClause += ", "
	updateClause += "client_oid = EXCLUDED.client_oid"
	updateClause += ", "
	updateClause += "exec_id = EXCLUDED.exec_id"
	updateClause += ", "
	updateClause += "symbol = EXCLUDED.symbol"
	updateClause += ", "
	updateClause += "side = EXCLUDED.side"
	updateClause += ", "
	updateClause += "price = EXCLUDED.price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "quote_qty = EXCLUDED.quote_qty"
	updateClause += ", "
	updateClause += "fee = EXCLUDED.fee"
	updateClause += ", "
	updateClause += "fee_asset = EXCLUDED.fee_asset"
	updateClause += ", "
	updateClause += "traded_at = EXCLUDED.traded_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result Executions
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *executionsDo) FindByIndex(ctx context.Context, req *ExecutionsIndex) ([]*ExecutionsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}
	if req.ClientOid != "" {
		builder = builder.Where(squirrel.Eq{"client_oid": req.ClientOid})
	}
	if req.ExecID != "" {
		builder = builder.Where(squirrel.Eq{"exec_id": req.ExecID})
	}
	if req.Symbol != "" {
		builder = builder.Where(squirrel.Eq{"symbol": req.Symbol})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id", "client_oid", "exec_id", "symbol")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*ExecutionsIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
