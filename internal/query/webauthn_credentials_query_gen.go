// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T18:09:36Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"

	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
)

// webauthnCredentials is the query entry point for WebauthnCredentials
var webauthnCredentials = newWebauthnCredentialsQuery()

// Default table alias for WebauthnCredentials (used in JOINs)
const WebauthnCredentialsAlias = "webauthnCredentials"

// newWebauthnCredentialsQuery creates a new query builder for WebauthnCredentials
func newWebauthnCredentialsQuery() *webauthnCredentialsQuery {
	return &webauthnCredentialsQuery{
		fieldMap: map[string]Field{
			"id":               webauthnCredentialsField.ID,
			"user_id":          webauthnCredentialsField.UserID,
			"webauthn_id":      webauthnCredentialsField.WebauthnID,
			"public_key":       webauthnCredentialsField.PublicKey,
			"attestation_type": webauthnCredentialsField.AttestationType,
			"transport":        webauthnCredentialsField.Transport,
			"aaguid":           webauthnCredentialsField.Aaguid,
			"sign_count":       webauthnCredentialsField.SignCount,
			"clone_warning":    webauthnCredentialsField.CloneWarning,
			"device_name":      webauthnCredentialsField.DeviceName,
			"created_at":       webauthnCredentialsField.CreatedAt,
			"last_used_at":     webauthnCredentialsField.LastUsedAt,
		},
		defaultAlias: WebauthnCredentialsAlias,
	}
}

// webauthnCredentialsQuery is the query builder for WebauthnCredentials
type webauthnCredentialsQuery struct {
	db           Executor
	fieldMap     map[string]Field
	defaultAlias string
}

// webauthnCredentialsField provides type-safe field access for WebauthnCredentials
var webauthnCredentialsField = struct {
	ID              Int64Field
	UserID          Int64Field
	WebauthnID      BytesField
	PublicKey       BytesField
	AttestationType StringField
	Transport       StringField
	Aaguid          StringField
	SignCount       Int64Field
	CloneWarning    BoolField
	DeviceName      StringField
	CreatedAt       TimeField
	LastUsedAt      TimeField
}{
	ID:              Int64Field("id"),
	UserID:          Int64Field("user_id"),
	WebauthnID:      BytesField("webauthn_id"),
	PublicKey:       BytesField("public_key"),
	AttestationType: StringField("attestation_type"),
	Transport:       StringField("transport"),
	Aaguid:          StringField("aaguid"),
	SignCount:       Int64Field("sign_count"),
	CloneWarning:    BoolField("clone_warning"),
	DeviceName:      StringField("device_name"),
	CreatedAt:       TimeField("created_at"),
	LastUsedAt:      TimeField("last_used_at"),
}

// WithDB returns a new query instance with the given database executor
func (q *webauthnCredentialsQuery) WithDB(db Executor) IWebauthnCredentialsDo {
	return &webauthnCredentialsDo{
		db:           db,
		table:        "\"public\".\"webauthn_credentials\"",
		alias:        q.defaultAlias, // 使用默认别名
		defaultAlias: q.defaultAlias,
		columns: []string{
			"id",
			"user_id",
			"webauthn_id",
			"public_key",
			"attestation_type",
			"transport",
			"aaguid",
			"sign_count",
			"clone_warning",
			"device_name",
			"created_at",
			"last_used_at",
		},
		Field: &webauthnCredentialsField,
	}
}

// IWebauthnCredentialsDo defines the interface for WebauthnCredentials data operations
type IWebauthnCredentialsDo interface {
	// Basic CRUD operations
	Create(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error)
	BatchCreate(ctx context.Context, models []*WebauthnCredentials) ([]*WebauthnCredentials, error)
	FindByPK(ctx context.Context, iD int64) (*WebauthnCredentials, error)
	FindByIndex(ctx context.Context, req *WebauthnCredentialsIndex) ([]*WebauthnCredentialsIndex, error)
	UpdateByPK(ctx context.Context, model *WebauthnCredentials) error
	DeleteByPK(ctx context.Context, iD int64) error
	Upsert(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error)
	UpsertAll(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error)

	// Query builder (type-safe, only accepts fields from this table)
	As(alias string) IWebauthnCredentialsDo
	Where(conds ...WhereCondition) IWebauthnCredentialsDo
	Select(fields ...Field) IWebauthnCredentialsDo
	SelectAgg(aggs ...AggregateFunc) IWebauthnCredentialsDo
	Distinct() IWebauthnCredentialsDo
	GroupBy(fields ...Field) IWebauthnCredentialsDo
	Having(cond squirrel.Sqlizer) IWebauthnCredentialsDo
	Order(orderBys ...OrderByClause) IWebauthnCredentialsDo
	Limit(limit int) IWebauthnCredentialsDo
	Offset(offset int) IWebauthnCredentialsDo

	// Execution methods
	Find(ctx context.Context) ([]*WebauthnCredentials, error)
	First(ctx context.Context) (*WebauthnCredentials, error)
	Count(ctx context.Context) (int64, error)
	Update(ctx context.Context, updates map[string]interface{}) (int64, error)
	Delete(ctx context.Context) (int64, error)

	// Transaction support
	WithDB(db Executor) IWebauthnCredentialsDo
}

// Ensure webauthnCredentialsDo implements IWebauthnCredentialsDo
var _ IWebauthnCredentialsDo = (*webauthnCredentialsDo)(nil)

// webauthnCredentialsDo wraps the query builder with chainable methods
type webauthnCredentialsDo struct {
	db           Executor
	table        string
	alias        string // 自定义别名（通过 As() 设置）
	defaultAlias string // 默认别名（模型名）
	columns      []string
	builder      squirrel.SelectBuilder

	// Field provides type-safe field access for this model
	Field *struct {
		ID              Int64Field
		UserID          Int64Field
		WebauthnID      BytesField
		PublicKey       BytesField
		AttestationType StringField
		Transport       StringField
		Aaguid          StringField
		SignCount       Int64Field
		CloneWarning    BoolField
		DeviceName      StringField
		CreatedAt       TimeField
		LastUsedAt      TimeField
	}

	// Query state
	whereSet    bool
	selectSet   bool
	distinctSet bool
	groupBySet  bool
	havingSet   bool
	orderSet    bool
	limitSet    bool
	offsetSet   bool

	// Store GROUP BY fields
	groupByFields []Field

	// Store aggregate functions for SELECT
	aggFuncs []AggregateFunc

	// Store WHERE conditions for reuse in Update/Delete
	whereConds []squirrel.Sqlizer
}

// WithDB returns a new DO instance with the given database executor (for transactions)
func (d *webauthnCredentialsDo) WithDB(db Executor) IWebauthnCredentialsDo {
	return &webauthnCredentialsDo{
		db:            db,
		table:         d.table,
		alias:         d.alias,
		defaultAlias:  d.defaultAlias,
		columns:       d.columns,
		builder:       d.builder,
		Field:         d.Field,
		whereSet:      d.whereSet,
		selectSet:     d.selectSet,
		distinctSet:   d.distinctSet,
		groupBySet:    d.groupBySet,
		havingSet:     d.havingSet,
		orderSet:      d.orderSet,
		limitSet:      d.limitSet,
		offsetSet:     d.offsetSet,
		whereConds:    d.whereConds,
		groupByFields: d.groupByFields,
		aggFuncs:      d.aggFuncs,
	}
}

// As sets a custom table alias for the query
// This is OPTIONAL - a default alias is already set automatically
// Use this only when you need a different alias (e.g., self-join)
// Example: query.user.WithDB(db).As("u1") for self-join scenarios
func (d *webauthnCredentialsDo) As(alias string) IWebauthnCredentialsDo {
	newDo := *d
	newDo.alias = alias
	newDo.Field = d.Field
	return &newDo
}

// getTableExpr returns the table expression with alias
// Always uses an alias (either custom via As() or default)
func (d *webauthnCredentialsDo) getTableExpr() string {
	alias := d.alias
	if alias == "" {
		alias = d.defaultAlias
	}
	return d.table + " AS " + alias
}

// Where adds WHERE conditions (chainable)
func (d *webauthnCredentialsDo) Where(conds ...WhereCondition) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	for _, cond := range conds {
		sqlizer := cond.ToSqlizer()
		d.builder = d.builder.Where(sqlizer)
		d.whereConds = append(d.whereConds, sqlizer)
	}
	return d
}

// Select specifies which fields to select (chainable)
func (d *webauthnCredentialsDo) Select(fields ...Field) IWebauthnCredentialsDo {
	if !d.selectSet {
		if !d.whereSet {
			d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
			d.whereSet = true
		}
		d.selectSet = true
	}
	cols := make([]string, len(fields))
	for i, f := range fields {
		cols[i] = f.ColumnName()
	}
	d.builder = d.builder.Columns(cols...)
	return d
}

// Distinct adds DISTINCT to the query (chainable)
// Example: query.user.WithDB(db).Select(userField.Email).Distinct().Find(ctx)
func (d *webauthnCredentialsDo) Distinct() IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Distinct()
	d.distinctSet = true
	return d
}

// SelectAgg selects aggregate functions (chainable)
// Example: query.order.WithDB(db).SelectAgg(orderField.Amount.Sum().As("total"), orderField.ID.Count().As("count"))
func (d *webauthnCredentialsDo) SelectAgg(aggs ...AggregateFunc) IWebauthnCredentialsDo {
	if !d.selectSet {
		if !d.whereSet {
			d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
			d.whereSet = true
		}
		d.selectSet = true
	}

	cols := make([]string, len(aggs))
	for i, agg := range aggs {
		cols[i] = agg.ToSQL()
	}
	d.builder = d.builder.Columns(cols...)
	d.aggFuncs = append(d.aggFuncs, aggs...)
	return d
}

// GroupBy adds GROUP BY clause (chainable)
// Example: query.order.WithDB(db).Select(orderField.UserID).SelectAgg(orderField.Amount.Sum()).GroupBy(orderField.UserID)
func (d *webauthnCredentialsDo) GroupBy(fields ...Field) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}

	cols := make([]string, len(fields))
	for i, f := range fields {
		cols[i] = f.ColumnName()
	}
	d.builder = d.builder.GroupBy(cols...)
	d.groupBySet = true
	d.groupByFields = append(d.groupByFields, fields...)
	return d
}

// Having adds HAVING clause (chainable, used with GROUP BY)
// Example: query.order.WithDB(db).GroupBy(orderField.UserID).Having(squirrel.Gt{"SUM(amount)": 1000})
func (d *webauthnCredentialsDo) Having(cond squirrel.Sqlizer) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Having(cond)
	d.havingSet = true
	return d
}

// Order adds ORDER BY clause (chainable, type-safe)
// Only accepts OrderByClause from this table's fields (e.g., webauthnCredentialsField.Age.Desc())
func (d *webauthnCredentialsDo) Order(orderBys ...OrderByClause) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	orderStrs := make([]string, len(orderBys))
	for i, ob := range orderBys {
		orderStrs[i] = ob.ToSQL()
	}
	d.builder = d.builder.OrderBy(orderStrs...)
	d.orderSet = true
	return d
}

// Limit sets the LIMIT clause (chainable)
func (d *webauthnCredentialsDo) Limit(limit int) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Limit(uint64(limit))
	d.limitSet = true
	return d
}

// Offset sets the OFFSET clause (chainable)
func (d *webauthnCredentialsDo) Offset(offset int) IWebauthnCredentialsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Offset(uint64(offset))
	d.offsetSet = true
	return d
}

// Find executes the query and returns all matching records
func (d *webauthnCredentialsDo) Find(ctx context.Context) ([]*WebauthnCredentials, error) {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}

	if !d.selectSet {
		d.builder = d.builder.Columns(d.columns...)
	}

	query, args, err := d.builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find query: %w", err)
	}
	var results []*WebauthnCredentials
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find: %w", err)
	}
	return results, nil
}

// First executes the query and returns the first matching record
func (d *webauthnCredentialsDo) First(ctx context.Context) (*WebauthnCredentials, error) {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}

	if !d.selectSet {
		d.builder = d.builder.Columns(d.columns...)
	}
	d.builder = d.builder.Limit(1)

	query, args, err := d.builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build first query: %w", err)
	}

	var result WebauthnCredentials
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("execute first: %w", err)
	}
	return &result, nil
}

// Count returns the number of matching records
func (d *webauthnCredentialsDo) Count(ctx context.Context) (int64, error) {
	countBuilder := squirrel.Select("COUNT(*)").From(d.getTableExpr()).PlaceholderFormat(squirrel.Dollar)

	// Apply stored WHERE conditions
	for _, cond := range d.whereConds {
		countBuilder = countBuilder.Where(cond)
	}

	query, args, err := countBuilder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build count query: %w", err)
	}

	var count int64
	err = d.db.QueryRowCtx(ctx, &count, query, args...)
	if err != nil {
		return 0, fmt.Errorf("execute count: %w", err)
	}
	return count, nil
}

// Update updates matching records with the given field-value pairs
func (d *webauthnCredentialsDo) Update(ctx context.Context, updates map[string]interface{}) (int64, error) {
	builder := squirrel.Update(d.table).PlaceholderFormat(squirrel.Dollar)

	for col, val := range updates {
		builder = builder.Set(col, val)
	}

	// Apply stored WHERE conditions
	for _, cond := range d.whereConds {
		builder = builder.Where(cond)
	}

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("execute update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("get rows affected: %w", err)
	}
	return affected, nil
}

// Delete deletes matching records
func (d *webauthnCredentialsDo) Delete(ctx context.Context) (int64, error) {
	builder := squirrel.Delete(d.table).PlaceholderFormat(squirrel.Dollar)

	// Apply stored WHERE conditions
	for _, cond := range d.whereConds {
		builder = builder.Where(cond)
	}

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("execute delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("get rows affected: %w", err)
	}
	return affected, nil
}
