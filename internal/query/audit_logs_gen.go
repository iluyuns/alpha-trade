// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T18:09:36Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// AuditLogs represents a row in table "public"."audit_logs".
//
// Indexes:
//   - audit_logs_pkey (PRIMARY KEY) (btree): id
type AuditLogs struct {
	ID         int64     `db:"id" json:"id"`                   // 日志自增 ID
	UserID     int64     `db:"user_id" json:"user_id"`         // 操作执行人 ID
	IpAddress  string    `db:"ip_address" json:"ip_address"`   // 操作者 IP 地址
	Action     string    `db:"action" json:"action"`           // 行为类型 [ENUM: KILL_SWITCH, UPDATE_RISK, API_KEY_ADD, STRATEGY_START]
	TargetType string    `db:"target_type" json:"target_type"` // 操作对象类别 [ENUM: ACCOUNT, RISK_CONFIG, STRATEGY, USER]
	TargetID   string    `db:"target_id" json:"target_id"`     // 操作对象 ID
	Changes    string    `db:"changes" json:"changes"`         // 变更 Diff 内容 [JSON: old, new]
	IsVerified bool      `db:"is_verified" json:"is_verified"` // 是否通过了 Passkey 二次提级认证
	CreatedAt  time.Time `db:"created_at" json:"created_at"`   // 审计记录时间
}

// TableName returns the table name for AuditLogs
func (m *AuditLogs) TableName() string {
	return "public.audit_logs"
}

// AuditLogsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type AuditLogsIndex struct {
	ID int64 `db:"id" json:"id"` // 日志自增 ID
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *auditLogsDo) Create(ctx context.Context, model *AuditLogs) (*AuditLogs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "ip_address", "action", "target_type", "target_id", "changes", "is_verified", "created_at").
		Values(model.UserID, model.IpAddress, model.Action, model.TargetType, model.TargetID, model.Changes, model.IsVerified, model.CreatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result AuditLogs
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *auditLogsDo) BatchCreate(ctx context.Context, models []*AuditLogs) ([]*AuditLogs, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "ip_address", "action", "target_type", "target_id", "changes", "is_verified", "created_at")

	for _, model := range models {
		builder = builder.Values(model.UserID, model.IpAddress, model.Action, model.TargetType, model.TargetID, model.Changes, model.IsVerified, model.CreatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*AuditLogs
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *auditLogsDo) FindByPK(ctx context.Context, iD int64) (*AuditLogs, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result AuditLogs
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *auditLogsDo) UpdateByPK(ctx context.Context, model *AuditLogs) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("user_id", model.UserID)
	builder = builder.Set("ip_address", model.IpAddress)
	builder = builder.Set("action", model.Action)
	builder = builder.Set("target_type", model.TargetType)
	builder = builder.Set("target_id", model.TargetID)
	builder = builder.Set("changes", model.Changes)
	builder = builder.Set("is_verified", model.IsVerified)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *auditLogsDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *auditLogsDo) Upsert(ctx context.Context, model *AuditLogs) (*AuditLogs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "ip_address", "action", "target_type", "target_id", "changes", "is_verified", "created_at").
		Values(model.UserID, model.IpAddress, model.Action, model.TargetType, model.TargetID, model.Changes, model.IsVerified, model.CreatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = CASE WHEN EXCLUDED.user_id = 0 THEN audit_logs.user_id ELSE EXCLUDED.user_id END"
	updateClause += ", "
	updateClause += "ip_address = CASE WHEN EXCLUDED.ip_address = '' THEN audit_logs.ip_address ELSE EXCLUDED.ip_address END"
	updateClause += ", "
	updateClause += "action = CASE WHEN EXCLUDED.action = '' THEN audit_logs.action ELSE EXCLUDED.action END"
	updateClause += ", "
	updateClause += "target_type = CASE WHEN EXCLUDED.target_type = '' THEN audit_logs.target_type ELSE EXCLUDED.target_type END"
	updateClause += ", "
	updateClause += "target_id = CASE WHEN EXCLUDED.target_id = '' THEN audit_logs.target_id ELSE EXCLUDED.target_id END"
	updateClause += ", "
	updateClause += "changes = CASE WHEN EXCLUDED.changes = '' THEN audit_logs.changes ELSE EXCLUDED.changes END"
	updateClause += ", "
	updateClause += "is_verified = EXCLUDED.is_verified"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result AuditLogs
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *auditLogsDo) UpsertAll(ctx context.Context, model *AuditLogs) (*AuditLogs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "ip_address", "action", "target_type", "target_id", "changes", "is_verified", "created_at").
		Values(model.UserID, model.IpAddress, model.Action, model.TargetType, model.TargetID, model.Changes, model.IsVerified, model.CreatedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = EXCLUDED.user_id"
	updateClause += ", "
	updateClause += "ip_address = EXCLUDED.ip_address"
	updateClause += ", "
	updateClause += "action = EXCLUDED.action"
	updateClause += ", "
	updateClause += "target_type = EXCLUDED.target_type"
	updateClause += ", "
	updateClause += "target_id = EXCLUDED.target_id"
	updateClause += ", "
	updateClause += "changes = EXCLUDED.changes"
	updateClause += ", "
	updateClause += "is_verified = EXCLUDED.is_verified"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result AuditLogs
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *auditLogsDo) FindByIndex(ctx context.Context, req *AuditLogsIndex) ([]*AuditLogsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*AuditLogsIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
