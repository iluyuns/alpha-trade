// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-18T14:25:30Z
// version: 1.0.0

package query

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/shopspring/decimal"
	"strings"
	"time"
)

// StrategyConfigs represents a row in table "public"."strategy_configs".
//
// Indexes:
//   - strategy_configs_pkey (PRIMARY KEY) (btree): key_name
type StrategyConfigs struct {
	KeyName     string          `db:"key_name" json:"key_name"`       // 配置键名 (e.g., risk.max_pos_ratio)
	ValueStr    string          `db:"value_str" json:"value_str"`     // 字符串类型值
	ValueNum    decimal.Decimal `db:"value_num" json:"value_num"`     // 数值类型值
	Description string          `db:"description" json:"description"` // 配置项含义描述
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`   // 最后修改时间
}

// TableName returns the table name for StrategyConfigs
func (m *StrategyConfigs) TableName() string {
	return "public.strategy_configs"
}

// StrategyConfigsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type StrategyConfigsIndex struct {
	KeyName string `db:"key_name" json:"key_name"` // 配置键名 (e.g., risk.max_pos_ratio)
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *strategyConfigsDo) Create(ctx context.Context, model *StrategyConfigs) (*StrategyConfigs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("key_name", "value_str", "value_num", "description", "updated_at").
		Values(model.KeyName, model.ValueStr, model.ValueNum, model.Description, model.UpdatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result StrategyConfigs
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.KeyName,
		&result.ValueStr,
		&result.ValueNum,
		&result.Description,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *strategyConfigsDo) BatchCreate(ctx context.Context, models []*StrategyConfigs) ([]*StrategyConfigs, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("key_name", "value_str", "value_num", "description", "updated_at")

	for _, model := range models {
		builder = builder.Values(model.KeyName, model.ValueStr, model.ValueNum, model.Description, model.UpdatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	defer rows.Close()

	var results []*StrategyConfigs
	for rows.Next() {
		var result StrategyConfigs
		err := rows.Scan(
			&result.KeyName,
			&result.ValueStr,
			&result.ValueNum,
			&result.Description,
			&result.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("scan batch insert result: %w", err)
		}
		results = append(results, &result)
	}
	return results, rows.Err()
}

// FindByPK finds a record by primary key
func (d *strategyConfigsDo) FindByPK(ctx context.Context, keyName string) (*StrategyConfigs, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"key_name": keyName,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result StrategyConfigs
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.KeyName,
		&result.ValueStr,
		&result.ValueNum,
		&result.Description,
		&result.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *strategyConfigsDo) UpdateByPK(ctx context.Context, model *StrategyConfigs) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("value_str", model.ValueStr)
	builder = builder.Set("value_num", model.ValueNum)
	builder = builder.Set("description", model.Description)
	builder = builder.Set("updated_at", model.UpdatedAt)
	builder = builder.Where(squirrel.Eq{
		"key_name": model.KeyName,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *strategyConfigsDo) DeleteByPK(ctx context.Context, keyName string) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"key_name": keyName,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *strategyConfigsDo) Upsert(ctx context.Context, model *StrategyConfigs) (*StrategyConfigs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("key_name", "value_str", "value_num", "description", "updated_at").
		Values(model.KeyName, model.ValueStr, model.ValueNum, model.Description, model.UpdatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (key_name) DO UPDATE SET "
	updateClause += "value_str = CASE WHEN EXCLUDED.value_str = '' THEN strategy_configs.value_str ELSE EXCLUDED.value_str END"
	updateClause += ", "
	updateClause += "value_num = EXCLUDED.value_num"
	updateClause += ", "
	updateClause += "description = CASE WHEN EXCLUDED.description = '' THEN strategy_configs.description ELSE EXCLUDED.description END"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result StrategyConfigs
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.KeyName,
		&result.ValueStr,
		&result.ValueNum,
		&result.Description,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *strategyConfigsDo) UpsertAll(ctx context.Context, model *StrategyConfigs) (*StrategyConfigs, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("key_name", "value_str", "value_num", "description", "updated_at").
		Values(model.KeyName, model.ValueStr, model.ValueNum, model.Description, model.UpdatedAt)

	updateClause := "ON CONFLICT (key_name) DO UPDATE SET "
	updateClause += "value_str = EXCLUDED.value_str"
	updateClause += ", "
	updateClause += "value_num = EXCLUDED.value_num"
	updateClause += ", "
	updateClause += "description = EXCLUDED.description"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result StrategyConfigs
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.KeyName,
		&result.ValueStr,
		&result.ValueNum,
		&result.Description,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *strategyConfigsDo) FindByIndex(ctx context.Context, req *StrategyConfigsIndex) ([]*StrategyConfigsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.KeyName != "" {
		builder = builder.Where(squirrel.Eq{"key_name": req.KeyName})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("key_name")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	defer rows.Close()

	var results []*StrategyConfigsIndex
	for rows.Next() {
		var result StrategyConfigsIndex
		err := rows.Scan(
			&result.KeyName,
		)
		if err != nil {
			return nil, fmt.Errorf("scan index result: %w", err)
		}
		results = append(results, &result)
	}
	return results, rows.Err()
}
