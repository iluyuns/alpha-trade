// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-18T14:25:30Z
// version: 1.0.0

package query

import (
	"context"
	"database/sql"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/shopspring/decimal"
	"strings"
	"time"
)

// Orders represents a row in table "public"."orders".
//
// Indexes:
//   - orders_pkey (PRIMARY KEY) (btree): id
//   - orders_client_oid_key (UNIQUE) (btree): client_oid
//   - idx_orders_client_oid (btree): client_oid
//   - idx_orders_status (btree): status
type Orders struct {
	ID         int64           `db:"id" json:"id"`                   // 本地流水 ID
	OrderID    string          `db:"order_id" json:"order_id"`       // 交易所原始订单 ID
	ClientOid  string          `db:"client_oid" json:"client_oid"`   // 本地生成的唯一 ID (幂等键)
	Exchange   string          `db:"exchange" json:"exchange"`       // 交易所名称
	Symbol     string          `db:"symbol" json:"symbol"`           // 交易对名称 (e.g., BTCUSDT)
	Side       string          `db:"side" json:"side"`               // 交易方向 [ENUM: BUY, SELL]
	Type       string          `db:"type" json:"type"`               // 委托类型 [ENUM: LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER]
	Price      decimal.Decimal `db:"price" json:"price"`             // 委托价格
	Quantity   decimal.Decimal `db:"quantity" json:"quantity"`       // 委托数量 (Base Asset)
	Amount     decimal.Decimal `db:"amount" json:"amount"`           // 委托金额 (Quote Asset，市价买单使用)
	Status     string          `db:"status" json:"status"`           // 订单状态 [ENUM: NEW, PARTIALLY_FILLED, FILLED, CANCELED, REJECTED, EXPIRED]
	AvgPrice   decimal.Decimal `db:"avg_price" json:"avg_price"`     // 成交均价
	FilledQty  decimal.Decimal `db:"filled_qty" json:"filled_qty"`   // 已成交数量
	CumQuote   decimal.Decimal `db:"cum_quote" json:"cum_quote"`     // 累计成交金额 (Quote Asset)
	StrategyID string          `db:"strategy_id" json:"strategy_id"` // 所属策略 ID
	ErrorMsg   string          `db:"error_msg" json:"error_msg"`     // 交易所返回的错误描述
	CreatedAt  time.Time       `db:"created_at" json:"created_at"`   // 订单创建时间
	UpdatedAt  time.Time       `db:"updated_at" json:"updated_at"`   // 状态最后同步时间
}

// TableName returns the table name for Orders
func (m *Orders) TableName() string {
	return "public.orders"
}

// OrdersIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type OrdersIndex struct {
	ID        int64  `db:"id" json:"id"`                 // 本地流水 ID
	ClientOid string `db:"client_oid" json:"client_oid"` // 本地生成的唯一 ID (幂等键)
	Status    string `db:"status" json:"status"`         // 订单状态 [ENUM: NEW, PARTIALLY_FILLED, FILLED, CANCELED, REJECTED, EXPIRED]
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *ordersDo) Create(ctx context.Context, model *Orders) (*Orders, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exchange", "symbol", "side", "type", "price", "quantity", "amount", "status", "avg_price", "filled_qty", "cum_quote", "strategy_id", "error_msg", "created_at", "updated_at").
		Values(model.OrderID, model.ClientOid, model.Exchange, model.Symbol, model.Side, model.Type, model.Price, model.Quantity, model.Amount, model.Status, model.AvgPrice, model.FilledQty, model.CumQuote, model.StrategyID, model.ErrorMsg, model.CreatedAt, model.UpdatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result Orders
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.ID,
		&result.OrderID,
		&result.ClientOid,
		&result.Exchange,
		&result.Symbol,
		&result.Side,
		&result.Type,
		&result.Price,
		&result.Quantity,
		&result.Amount,
		&result.Status,
		&result.AvgPrice,
		&result.FilledQty,
		&result.CumQuote,
		&result.StrategyID,
		&result.ErrorMsg,
		&result.CreatedAt,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *ordersDo) BatchCreate(ctx context.Context, models []*Orders) ([]*Orders, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exchange", "symbol", "side", "type", "price", "quantity", "amount", "status", "avg_price", "filled_qty", "cum_quote", "strategy_id", "error_msg", "created_at", "updated_at")

	for _, model := range models {
		builder = builder.Values(model.OrderID, model.ClientOid, model.Exchange, model.Symbol, model.Side, model.Type, model.Price, model.Quantity, model.Amount, model.Status, model.AvgPrice, model.FilledQty, model.CumQuote, model.StrategyID, model.ErrorMsg, model.CreatedAt, model.UpdatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	defer rows.Close()

	var results []*Orders
	for rows.Next() {
		var result Orders
		err := rows.Scan(
			&result.ID,
			&result.OrderID,
			&result.ClientOid,
			&result.Exchange,
			&result.Symbol,
			&result.Side,
			&result.Type,
			&result.Price,
			&result.Quantity,
			&result.Amount,
			&result.Status,
			&result.AvgPrice,
			&result.FilledQty,
			&result.CumQuote,
			&result.StrategyID,
			&result.ErrorMsg,
			&result.CreatedAt,
			&result.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("scan batch insert result: %w", err)
		}
		results = append(results, &result)
	}
	return results, rows.Err()
}

// FindByPK finds a record by primary key
func (d *ordersDo) FindByPK(ctx context.Context, iD int64) (*Orders, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result Orders
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.ID,
		&result.OrderID,
		&result.ClientOid,
		&result.Exchange,
		&result.Symbol,
		&result.Side,
		&result.Type,
		&result.Price,
		&result.Quantity,
		&result.Amount,
		&result.Status,
		&result.AvgPrice,
		&result.FilledQty,
		&result.CumQuote,
		&result.StrategyID,
		&result.ErrorMsg,
		&result.CreatedAt,
		&result.UpdatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *ordersDo) UpdateByPK(ctx context.Context, model *Orders) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("order_id", model.OrderID)
	builder = builder.Set("client_oid", model.ClientOid)
	builder = builder.Set("exchange", model.Exchange)
	builder = builder.Set("symbol", model.Symbol)
	builder = builder.Set("side", model.Side)
	builder = builder.Set("type", model.Type)
	builder = builder.Set("price", model.Price)
	builder = builder.Set("quantity", model.Quantity)
	builder = builder.Set("amount", model.Amount)
	builder = builder.Set("status", model.Status)
	builder = builder.Set("avg_price", model.AvgPrice)
	builder = builder.Set("filled_qty", model.FilledQty)
	builder = builder.Set("cum_quote", model.CumQuote)
	builder = builder.Set("strategy_id", model.StrategyID)
	builder = builder.Set("error_msg", model.ErrorMsg)
	builder = builder.Set("updated_at", model.UpdatedAt)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *ordersDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *ordersDo) Upsert(ctx context.Context, model *Orders) (*Orders, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exchange", "symbol", "side", "type", "price", "quantity", "amount", "status", "avg_price", "filled_qty", "cum_quote", "strategy_id", "error_msg", "created_at", "updated_at").
		Values(model.OrderID, model.ClientOid, model.Exchange, model.Symbol, model.Side, model.Type, model.Price, model.Quantity, model.Amount, model.Status, model.AvgPrice, model.FilledQty, model.CumQuote, model.StrategyID, model.ErrorMsg, model.CreatedAt, model.UpdatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "order_id = CASE WHEN EXCLUDED.order_id = '' THEN orders.order_id ELSE EXCLUDED.order_id END"
	updateClause += ", "
	updateClause += "client_oid = CASE WHEN EXCLUDED.client_oid = '' THEN orders.client_oid ELSE EXCLUDED.client_oid END"
	updateClause += ", "
	updateClause += "exchange = CASE WHEN EXCLUDED.exchange = '' THEN orders.exchange ELSE EXCLUDED.exchange END"
	updateClause += ", "
	updateClause += "symbol = CASE WHEN EXCLUDED.symbol = '' THEN orders.symbol ELSE EXCLUDED.symbol END"
	updateClause += ", "
	updateClause += "side = CASE WHEN EXCLUDED.side = '' THEN orders.side ELSE EXCLUDED.side END"
	updateClause += ", "
	updateClause += "type = CASE WHEN EXCLUDED.type = '' THEN orders.type ELSE EXCLUDED.type END"
	updateClause += ", "
	updateClause += "price = EXCLUDED.price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "amount = EXCLUDED.amount"
	updateClause += ", "
	updateClause += "status = CASE WHEN EXCLUDED.status = '' THEN orders.status ELSE EXCLUDED.status END"
	updateClause += ", "
	updateClause += "avg_price = EXCLUDED.avg_price"
	updateClause += ", "
	updateClause += "filled_qty = EXCLUDED.filled_qty"
	updateClause += ", "
	updateClause += "cum_quote = EXCLUDED.cum_quote"
	updateClause += ", "
	updateClause += "strategy_id = CASE WHEN EXCLUDED.strategy_id = '' THEN orders.strategy_id ELSE EXCLUDED.strategy_id END"
	updateClause += ", "
	updateClause += "error_msg = CASE WHEN EXCLUDED.error_msg = '' THEN orders.error_msg ELSE EXCLUDED.error_msg END"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result Orders
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.ID,
		&result.OrderID,
		&result.ClientOid,
		&result.Exchange,
		&result.Symbol,
		&result.Side,
		&result.Type,
		&result.Price,
		&result.Quantity,
		&result.Amount,
		&result.Status,
		&result.AvgPrice,
		&result.FilledQty,
		&result.CumQuote,
		&result.StrategyID,
		&result.ErrorMsg,
		&result.CreatedAt,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *ordersDo) UpsertAll(ctx context.Context, model *Orders) (*Orders, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("order_id", "client_oid", "exchange", "symbol", "side", "type", "price", "quantity", "amount", "status", "avg_price", "filled_qty", "cum_quote", "strategy_id", "error_msg", "created_at", "updated_at").
		Values(model.OrderID, model.ClientOid, model.Exchange, model.Symbol, model.Side, model.Type, model.Price, model.Quantity, model.Amount, model.Status, model.AvgPrice, model.FilledQty, model.CumQuote, model.StrategyID, model.ErrorMsg, model.CreatedAt, model.UpdatedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "order_id = EXCLUDED.order_id"
	updateClause += ", "
	updateClause += "client_oid = EXCLUDED.client_oid"
	updateClause += ", "
	updateClause += "exchange = EXCLUDED.exchange"
	updateClause += ", "
	updateClause += "symbol = EXCLUDED.symbol"
	updateClause += ", "
	updateClause += "side = EXCLUDED.side"
	updateClause += ", "
	updateClause += "type = EXCLUDED.type"
	updateClause += ", "
	updateClause += "price = EXCLUDED.price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "amount = EXCLUDED.amount"
	updateClause += ", "
	updateClause += "status = EXCLUDED.status"
	updateClause += ", "
	updateClause += "avg_price = EXCLUDED.avg_price"
	updateClause += ", "
	updateClause += "filled_qty = EXCLUDED.filled_qty"
	updateClause += ", "
	updateClause += "cum_quote = EXCLUDED.cum_quote"
	updateClause += ", "
	updateClause += "strategy_id = EXCLUDED.strategy_id"
	updateClause += ", "
	updateClause += "error_msg = EXCLUDED.error_msg"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result Orders
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.ID,
		&result.OrderID,
		&result.ClientOid,
		&result.Exchange,
		&result.Symbol,
		&result.Side,
		&result.Type,
		&result.Price,
		&result.Quantity,
		&result.Amount,
		&result.Status,
		&result.AvgPrice,
		&result.FilledQty,
		&result.CumQuote,
		&result.StrategyID,
		&result.ErrorMsg,
		&result.CreatedAt,
		&result.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *ordersDo) FindByIndex(ctx context.Context, req *OrdersIndex) ([]*OrdersIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}
	if req.ClientOid != "" {
		builder = builder.Where(squirrel.Eq{"client_oid": req.ClientOid})
	}
	if req.Status != "" {
		builder = builder.Where(squirrel.Eq{"status": req.Status})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id", "client_oid", "status")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	defer rows.Close()

	var results []*OrdersIndex
	for rows.Next() {
		var result OrdersIndex
		err := rows.Scan(
			&result.ID,
			&result.ClientOid,
			&result.Status,
		)
		if err != nil {
			return nil, fmt.Errorf("scan index result: %w", err)
		}
		results = append(results, &result)
	}
	return results, rows.Err()
}
