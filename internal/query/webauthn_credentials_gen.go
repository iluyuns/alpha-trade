// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T17:23:17Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// WebauthnCredentials represents a row in table "public"."webauthn_credentials".
//
// Indexes:
//   - webauthn_credentials_pkey (PRIMARY KEY) (btree): id
//   - webauthn_credentials_webauthn_id_key (UNIQUE) (btree): webauthn_id
type WebauthnCredentials struct {
	ID              int64     `db:"id" json:"id"`                             // 凭证自增 ID
	UserID          int64     `db:"user_id" json:"user_id"`                   // 关联的用户 ID
	WebauthnID      []byte    `db:"webauthn_id" json:"webauthn_id"`           // 浏览器返回的唯一凭证 ID
	PublicKey       []byte    `db:"public_key" json:"public_key"`             // COSE 编码的认证公钥
	AttestationType string    `db:"attestation_type" json:"attestation_type"` // 认证器声明类型
	Transport       string    `db:"transport" json:"transport"`               // 支持的传输协议 [ENUM: usb, nfc, ble, internal, hybrid]
	Aaguid          string    `db:"aaguid" json:"aaguid"`                     // 验证器型号唯一标识
	SignCount       int64     `db:"sign_count" json:"sign_count"`             // 签名计数器：用于检测凭证克隆风险
	CloneWarning    bool      `db:"clone_warning" json:"clone_warning"`       // 凭证是否存在克隆嫌疑标记
	DeviceName      string    `db:"device_name" json:"device_name"`           // 用户定义的硬件设备名称
	CreatedAt       time.Time `db:"created_at" json:"created_at"`             // 凭证注册时间
	LastUsedAt      time.Time `db:"last_used_at" json:"last_used_at"`         // 最后一次认证时间
}

// TableName returns the table name for WebauthnCredentials
func (m *WebauthnCredentials) TableName() string {
	return "public.webauthn_credentials"
}

// WebauthnCredentialsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type WebauthnCredentialsIndex struct {
	ID         int64  `db:"id" json:"id"`                   // 凭证自增 ID
	WebauthnID []byte `db:"webauthn_id" json:"webauthn_id"` // 浏览器返回的唯一凭证 ID
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *webauthnCredentialsDo) Create(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "webauthn_id", "public_key", "attestation_type", "transport", "aaguid", "sign_count", "clone_warning", "device_name", "created_at", "last_used_at").
		Values(model.UserID, model.WebauthnID, model.PublicKey, model.AttestationType, model.Transport, model.Aaguid, model.SignCount, model.CloneWarning, model.DeviceName, model.CreatedAt, model.LastUsedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result WebauthnCredentials
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *webauthnCredentialsDo) BatchCreate(ctx context.Context, models []*WebauthnCredentials) ([]*WebauthnCredentials, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "webauthn_id", "public_key", "attestation_type", "transport", "aaguid", "sign_count", "clone_warning", "device_name", "created_at", "last_used_at")

	for _, model := range models {
		builder = builder.Values(model.UserID, model.WebauthnID, model.PublicKey, model.AttestationType, model.Transport, model.Aaguid, model.SignCount, model.CloneWarning, model.DeviceName, model.CreatedAt, model.LastUsedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*WebauthnCredentials
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *webauthnCredentialsDo) FindByPK(ctx context.Context, iD int64) (*WebauthnCredentials, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result WebauthnCredentials
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *webauthnCredentialsDo) UpdateByPK(ctx context.Context, model *WebauthnCredentials) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("user_id", model.UserID)
	builder = builder.Set("webauthn_id", model.WebauthnID)
	builder = builder.Set("public_key", model.PublicKey)
	builder = builder.Set("attestation_type", model.AttestationType)
	builder = builder.Set("transport", model.Transport)
	builder = builder.Set("aaguid", model.Aaguid)
	builder = builder.Set("sign_count", model.SignCount)
	builder = builder.Set("clone_warning", model.CloneWarning)
	builder = builder.Set("device_name", model.DeviceName)
	builder = builder.Set("last_used_at", model.LastUsedAt)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *webauthnCredentialsDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *webauthnCredentialsDo) Upsert(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "webauthn_id", "public_key", "attestation_type", "transport", "aaguid", "sign_count", "clone_warning", "device_name", "created_at", "last_used_at").
		Values(model.UserID, model.WebauthnID, model.PublicKey, model.AttestationType, model.Transport, model.Aaguid, model.SignCount, model.CloneWarning, model.DeviceName, model.CreatedAt, model.LastUsedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = CASE WHEN EXCLUDED.user_id = 0 THEN webauthn_credentials.user_id ELSE EXCLUDED.user_id END"
	updateClause += ", "
	updateClause += "webauthn_id = EXCLUDED.webauthn_id"
	updateClause += ", "
	updateClause += "public_key = EXCLUDED.public_key"
	updateClause += ", "
	updateClause += "attestation_type = CASE WHEN EXCLUDED.attestation_type = '' THEN webauthn_credentials.attestation_type ELSE EXCLUDED.attestation_type END"
	updateClause += ", "
	updateClause += "transport = CASE WHEN EXCLUDED.transport = '' THEN webauthn_credentials.transport ELSE EXCLUDED.transport END"
	updateClause += ", "
	updateClause += "aaguid = CASE WHEN EXCLUDED.aaguid = '' THEN webauthn_credentials.aaguid ELSE EXCLUDED.aaguid END"
	updateClause += ", "
	updateClause += "sign_count = CASE WHEN EXCLUDED.sign_count = 0 THEN webauthn_credentials.sign_count ELSE EXCLUDED.sign_count END"
	updateClause += ", "
	updateClause += "clone_warning = EXCLUDED.clone_warning"
	updateClause += ", "
	updateClause += "device_name = CASE WHEN EXCLUDED.device_name = '' THEN webauthn_credentials.device_name ELSE EXCLUDED.device_name END"
	updateClause += ", "
	updateClause += "last_used_at = EXCLUDED.last_used_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result WebauthnCredentials
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *webauthnCredentialsDo) UpsertAll(ctx context.Context, model *WebauthnCredentials) (*WebauthnCredentials, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "webauthn_id", "public_key", "attestation_type", "transport", "aaguid", "sign_count", "clone_warning", "device_name", "created_at", "last_used_at").
		Values(model.UserID, model.WebauthnID, model.PublicKey, model.AttestationType, model.Transport, model.Aaguid, model.SignCount, model.CloneWarning, model.DeviceName, model.CreatedAt, model.LastUsedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = EXCLUDED.user_id"
	updateClause += ", "
	updateClause += "webauthn_id = EXCLUDED.webauthn_id"
	updateClause += ", "
	updateClause += "public_key = EXCLUDED.public_key"
	updateClause += ", "
	updateClause += "attestation_type = EXCLUDED.attestation_type"
	updateClause += ", "
	updateClause += "transport = EXCLUDED.transport"
	updateClause += ", "
	updateClause += "aaguid = EXCLUDED.aaguid"
	updateClause += ", "
	updateClause += "sign_count = EXCLUDED.sign_count"
	updateClause += ", "
	updateClause += "clone_warning = EXCLUDED.clone_warning"
	updateClause += ", "
	updateClause += "device_name = EXCLUDED.device_name"
	updateClause += ", "
	updateClause += "last_used_at = EXCLUDED.last_used_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result WebauthnCredentials
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *webauthnCredentialsDo) FindByIndex(ctx context.Context, req *WebauthnCredentialsIndex) ([]*WebauthnCredentialsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id", "webauthn_id")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*WebauthnCredentialsIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
