// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T17:23:17Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/shopspring/decimal"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// Settlements represents a row in table "public"."settlements".
//
// Indexes:
//   - settlements_pkey (PRIMARY KEY) (btree): id
type Settlements struct {
	ID              int64           `db:"id" json:"id"`                             // 结算单 ID
	TradeID         string          `db:"trade_id" json:"trade_id"`                 // 逻辑交易 ID (跨订单关联标识)
	Symbol          string          `db:"symbol" json:"symbol"`                     // 交易对
	MarketType      string          `db:"market_type" json:"market_type"`           // 市场类型 [ENUM: SPOT, SWAP, FUTURE]
	Side            string          `db:"side" json:"side"`                         // 盈亏方向 [ENUM: LONG, SHORT]
	RealizedPnl     decimal.Decimal `db:"realized_pnl" json:"realized_pnl"`         // 已实现净盈亏 (扣费后)
	Commission      decimal.Decimal `db:"commission" json:"commission"`             // 累计手续费支出
	FundingFee      decimal.Decimal `db:"funding_fee" json:"funding_fee"`           // 累计资金费支出 (仅限合约)
	EntryPrice      decimal.Decimal `db:"entry_price" json:"entry_price"`           // 平均开仓价
	ExitPrice       decimal.Decimal `db:"exit_price" json:"exit_price"`             // 平均平仓价
	Quantity        decimal.Decimal `db:"quantity" json:"quantity"`                 // 结算头寸数量
	Roi             decimal.Decimal `db:"roi" json:"roi"`                           // 收益率百分比
	OpenedAt        time.Time       `db:"opened_at" json:"opened_at"`               // 逻辑开仓时间
	ClosedAt        time.Time       `db:"closed_at" json:"closed_at"`               // 逻辑平仓时间
	DurationSeconds int64           `db:"duration_seconds" json:"duration_seconds"` // 持仓总时长 (秒)
	Metadata        string          `db:"metadata" json:"metadata"`                 // 扩展元数据 [JSON: leverage, liq_price]
	CreatedAt       time.Time       `db:"created_at" json:"created_at"`             // 记录生成时间
}

// TableName returns the table name for Settlements
func (m *Settlements) TableName() string {
	return "public.settlements"
}

// SettlementsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type SettlementsIndex struct {
	ID int64 `db:"id" json:"id"` // 结算单 ID
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *settlementsDo) Create(ctx context.Context, model *Settlements) (*Settlements, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("trade_id", "symbol", "market_type", "side", "realized_pnl", "commission", "funding_fee", "entry_price", "exit_price", "quantity", "roi", "opened_at", "closed_at", "duration_seconds", "metadata", "created_at").
		Values(model.TradeID, model.Symbol, model.MarketType, model.Side, model.RealizedPnl, model.Commission, model.FundingFee, model.EntryPrice, model.ExitPrice, model.Quantity, model.Roi, model.OpenedAt, model.ClosedAt, model.DurationSeconds, model.Metadata, model.CreatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result Settlements
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *settlementsDo) BatchCreate(ctx context.Context, models []*Settlements) ([]*Settlements, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("trade_id", "symbol", "market_type", "side", "realized_pnl", "commission", "funding_fee", "entry_price", "exit_price", "quantity", "roi", "opened_at", "closed_at", "duration_seconds", "metadata", "created_at")

	for _, model := range models {
		builder = builder.Values(model.TradeID, model.Symbol, model.MarketType, model.Side, model.RealizedPnl, model.Commission, model.FundingFee, model.EntryPrice, model.ExitPrice, model.Quantity, model.Roi, model.OpenedAt, model.ClosedAt, model.DurationSeconds, model.Metadata, model.CreatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*Settlements
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *settlementsDo) FindByPK(ctx context.Context, iD int64) (*Settlements, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result Settlements
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *settlementsDo) UpdateByPK(ctx context.Context, model *Settlements) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("trade_id", model.TradeID)
	builder = builder.Set("symbol", model.Symbol)
	builder = builder.Set("market_type", model.MarketType)
	builder = builder.Set("side", model.Side)
	builder = builder.Set("realized_pnl", model.RealizedPnl)
	builder = builder.Set("commission", model.Commission)
	builder = builder.Set("funding_fee", model.FundingFee)
	builder = builder.Set("entry_price", model.EntryPrice)
	builder = builder.Set("exit_price", model.ExitPrice)
	builder = builder.Set("quantity", model.Quantity)
	builder = builder.Set("roi", model.Roi)
	builder = builder.Set("opened_at", model.OpenedAt)
	builder = builder.Set("closed_at", model.ClosedAt)
	builder = builder.Set("duration_seconds", model.DurationSeconds)
	builder = builder.Set("metadata", model.Metadata)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *settlementsDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *settlementsDo) Upsert(ctx context.Context, model *Settlements) (*Settlements, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("trade_id", "symbol", "market_type", "side", "realized_pnl", "commission", "funding_fee", "entry_price", "exit_price", "quantity", "roi", "opened_at", "closed_at", "duration_seconds", "metadata", "created_at").
		Values(model.TradeID, model.Symbol, model.MarketType, model.Side, model.RealizedPnl, model.Commission, model.FundingFee, model.EntryPrice, model.ExitPrice, model.Quantity, model.Roi, model.OpenedAt, model.ClosedAt, model.DurationSeconds, model.Metadata, model.CreatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "trade_id = CASE WHEN EXCLUDED.trade_id = '' THEN settlements.trade_id ELSE EXCLUDED.trade_id END"
	updateClause += ", "
	updateClause += "symbol = CASE WHEN EXCLUDED.symbol = '' THEN settlements.symbol ELSE EXCLUDED.symbol END"
	updateClause += ", "
	updateClause += "market_type = CASE WHEN EXCLUDED.market_type = '' THEN settlements.market_type ELSE EXCLUDED.market_type END"
	updateClause += ", "
	updateClause += "side = CASE WHEN EXCLUDED.side = '' THEN settlements.side ELSE EXCLUDED.side END"
	updateClause += ", "
	updateClause += "realized_pnl = EXCLUDED.realized_pnl"
	updateClause += ", "
	updateClause += "commission = EXCLUDED.commission"
	updateClause += ", "
	updateClause += "funding_fee = EXCLUDED.funding_fee"
	updateClause += ", "
	updateClause += "entry_price = EXCLUDED.entry_price"
	updateClause += ", "
	updateClause += "exit_price = EXCLUDED.exit_price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "roi = EXCLUDED.roi"
	updateClause += ", "
	updateClause += "opened_at = EXCLUDED.opened_at"
	updateClause += ", "
	updateClause += "closed_at = EXCLUDED.closed_at"
	updateClause += ", "
	updateClause += "duration_seconds = CASE WHEN EXCLUDED.duration_seconds = 0 THEN settlements.duration_seconds ELSE EXCLUDED.duration_seconds END"
	updateClause += ", "
	updateClause += "metadata = CASE WHEN EXCLUDED.metadata = '' THEN settlements.metadata ELSE EXCLUDED.metadata END"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result Settlements
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *settlementsDo) UpsertAll(ctx context.Context, model *Settlements) (*Settlements, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("trade_id", "symbol", "market_type", "side", "realized_pnl", "commission", "funding_fee", "entry_price", "exit_price", "quantity", "roi", "opened_at", "closed_at", "duration_seconds", "metadata", "created_at").
		Values(model.TradeID, model.Symbol, model.MarketType, model.Side, model.RealizedPnl, model.Commission, model.FundingFee, model.EntryPrice, model.ExitPrice, model.Quantity, model.Roi, model.OpenedAt, model.ClosedAt, model.DurationSeconds, model.Metadata, model.CreatedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "trade_id = EXCLUDED.trade_id"
	updateClause += ", "
	updateClause += "symbol = EXCLUDED.symbol"
	updateClause += ", "
	updateClause += "market_type = EXCLUDED.market_type"
	updateClause += ", "
	updateClause += "side = EXCLUDED.side"
	updateClause += ", "
	updateClause += "realized_pnl = EXCLUDED.realized_pnl"
	updateClause += ", "
	updateClause += "commission = EXCLUDED.commission"
	updateClause += ", "
	updateClause += "funding_fee = EXCLUDED.funding_fee"
	updateClause += ", "
	updateClause += "entry_price = EXCLUDED.entry_price"
	updateClause += ", "
	updateClause += "exit_price = EXCLUDED.exit_price"
	updateClause += ", "
	updateClause += "quantity = EXCLUDED.quantity"
	updateClause += ", "
	updateClause += "roi = EXCLUDED.roi"
	updateClause += ", "
	updateClause += "opened_at = EXCLUDED.opened_at"
	updateClause += ", "
	updateClause += "closed_at = EXCLUDED.closed_at"
	updateClause += ", "
	updateClause += "duration_seconds = EXCLUDED.duration_seconds"
	updateClause += ", "
	updateClause += "metadata = EXCLUDED.metadata"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result Settlements
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *settlementsDo) FindByIndex(ctx context.Context, req *SettlementsIndex) ([]*SettlementsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*SettlementsIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
