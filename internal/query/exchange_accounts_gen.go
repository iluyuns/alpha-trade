// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-19T17:23:17Z
// version: 1.0.0

package query

import (
	"context"
	"fmt"
	"github.com/Masterminds/squirrel"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"strings"
	"time"
)

// ExchangeAccounts represents a row in table "public"."exchange_accounts".
//
// Indexes:
//   - exchange_accounts_pkey (PRIMARY KEY) (btree): id
type ExchangeAccounts struct {
	ID                  int64     `db:"id" json:"id"`                                     // 账户自增 ID
	UserID              int64     `db:"user_id" json:"user_id"`                           // 所属系统用户 ID
	Label               string    `db:"label" json:"label"`                               // 账户备注名称 (e.g., Binance_Sub_01)
	Exchange            string    `db:"exchange" json:"exchange"`                         // 交易所类型 [ENUM: BINANCE, OKX]
	ApiKey              string    `db:"api_key" json:"api_key"`                           // 交易所 API Key
	EncryptedApiSecret  string    `db:"encrypted_api_secret" json:"encrypted_api_secret"` // 加密后的 API Secret (AES-256-GCM)
	EncryptedPassphrase string    `db:"encrypted_passphrase" json:"encrypted_passphrase"` // 加密后的 OKX Passphrase (仅 OKX 必填)
	Config              string    `db:"config" json:"config"`                             // 扩展配置 [JSON: ip_whitelist, is_master]
	IsActive            bool      `db:"is_active" json:"is_active"`                       // 账户启用状态
	CreatedAt           time.Time `db:"created_at" json:"created_at"`                     // 记录创建时间
	UpdatedAt           time.Time `db:"updated_at" json:"updated_at"`                     // 最后更新时间
}

// TableName returns the table name for ExchangeAccounts
func (m *ExchangeAccounts) TableName() string {
	return "public.exchange_accounts"
}

// ExchangeAccountsIndex represents indexed columns for covering index queries.
// Only includes columns that appear in at least one index, enabling index-only scans.
type ExchangeAccountsIndex struct {
	ID int64 `db:"id" json:"id"` // 账户自增 ID
}

// Create inserts a new record and returns the inserted record with auto-generated fields
func (d *exchangeAccountsDo) Create(ctx context.Context, model *ExchangeAccounts) (*ExchangeAccounts, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "label", "exchange", "api_key", "encrypted_api_secret", "encrypted_passphrase", "config", "is_active", "created_at", "updated_at").
		Values(model.UserID, model.Label, model.Exchange, model.ApiKey, model.EncryptedApiSecret, model.EncryptedPassphrase, model.Config, model.IsActive, model.CreatedAt, model.UpdatedAt).
		Suffix("RETURNING " + strings.Join(d.columns, ", "))

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build insert query: %w", err)
	}

	var result ExchangeAccounts
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("insert: %w", err)
	}
	return &result, nil
}

// BatchCreate inserts multiple records and returns all inserted records
func (d *exchangeAccountsDo) BatchCreate(ctx context.Context, models []*ExchangeAccounts) ([]*ExchangeAccounts, error) {
	if len(models) == 0 {
		return nil, nil
	}

	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "label", "exchange", "api_key", "encrypted_api_secret", "encrypted_passphrase", "config", "is_active", "created_at", "updated_at")

	for _, model := range models {
		builder = builder.Values(model.UserID, model.Label, model.Exchange, model.ApiKey, model.EncryptedApiSecret, model.EncryptedPassphrase, model.Config, model.IsActive, model.CreatedAt, model.UpdatedAt)
	}

	builder = builder.Suffix("RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build batch insert query: %w", err)
	}
	var results []*ExchangeAccounts
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("batch insert: %w", err)
	}
	return results, nil
}

// FindByPK finds a record by primary key
func (d *exchangeAccountsDo) FindByPK(ctx context.Context, iD int64) (*ExchangeAccounts, error) {
	builder := squirrel.Select(d.columns...).
		From(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		}).
		Limit(1)

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build select query: %w", err)
	}

	var result ExchangeAccounts
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err == sqlx.ErrNotFound {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("find by pk: %w", err)
	}
	return &result, nil
}

// UpdateByPK updates a record by primary key
func (d *exchangeAccountsDo) UpdateByPK(ctx context.Context, model *ExchangeAccounts) error {
	builder := squirrel.Update(d.table).
		PlaceholderFormat(squirrel.Dollar)
	builder = builder.Set("user_id", model.UserID)
	builder = builder.Set("label", model.Label)
	builder = builder.Set("exchange", model.Exchange)
	builder = builder.Set("api_key", model.ApiKey)
	builder = builder.Set("encrypted_api_secret", model.EncryptedApiSecret)
	builder = builder.Set("encrypted_passphrase", model.EncryptedPassphrase)
	builder = builder.Set("config", model.Config)
	builder = builder.Set("is_active", model.IsActive)
	builder = builder.Set("updated_at", model.UpdatedAt)
	builder = builder.Where(squirrel.Eq{
		"id": model.ID,
	})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build update query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// DeleteByPK deletes a record by primary key
func (d *exchangeAccountsDo) DeleteByPK(ctx context.Context, iD int64) error {
	builder := squirrel.Delete(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{
			"id": iD,
		})

	query, args, err := builder.ToSql()
	if err != nil {
		return fmt.Errorf("build delete query: %w", err)
	}
	result, err := d.db.ExecCtx(ctx, query, args...)
	if err != nil {
		return fmt.Errorf("delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("get rows affected: %w", err)
	}
	if affected == 0 {
		return ErrRecordNotFound
	}
	return nil
}

// Upsert inserts or updates a record (uses ON CONFLICT for PostgreSQL)
// Only updates non-zero fields on conflict
func (d *exchangeAccountsDo) Upsert(ctx context.Context, model *ExchangeAccounts) (*ExchangeAccounts, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "label", "exchange", "api_key", "encrypted_api_secret", "encrypted_passphrase", "config", "is_active", "created_at", "updated_at").
		Values(model.UserID, model.Label, model.Exchange, model.ApiKey, model.EncryptedApiSecret, model.EncryptedPassphrase, model.Config, model.IsActive, model.CreatedAt, model.UpdatedAt)

	// Build update clause for conflict resolution
	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = CASE WHEN EXCLUDED.user_id = 0 THEN exchange_accounts.user_id ELSE EXCLUDED.user_id END"
	updateClause += ", "
	updateClause += "label = CASE WHEN EXCLUDED.label = '' THEN exchange_accounts.label ELSE EXCLUDED.label END"
	updateClause += ", "
	updateClause += "exchange = CASE WHEN EXCLUDED.exchange = '' THEN exchange_accounts.exchange ELSE EXCLUDED.exchange END"
	updateClause += ", "
	updateClause += "api_key = CASE WHEN EXCLUDED.api_key = '' THEN exchange_accounts.api_key ELSE EXCLUDED.api_key END"
	updateClause += ", "
	updateClause += "encrypted_api_secret = CASE WHEN EXCLUDED.encrypted_api_secret = '' THEN exchange_accounts.encrypted_api_secret ELSE EXCLUDED.encrypted_api_secret END"
	updateClause += ", "
	updateClause += "encrypted_passphrase = CASE WHEN EXCLUDED.encrypted_passphrase = '' THEN exchange_accounts.encrypted_passphrase ELSE EXCLUDED.encrypted_passphrase END"
	updateClause += ", "
	updateClause += "config = CASE WHEN EXCLUDED.config = '' THEN exchange_accounts.config ELSE EXCLUDED.config END"
	updateClause += ", "
	updateClause += "is_active = EXCLUDED.is_active"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert query: %w", err)
	}

	var result ExchangeAccounts
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert: %w", err)
	}
	return &result, nil
}

// UpsertAll inserts or updates a record, updating all fields on conflict
func (d *exchangeAccountsDo) UpsertAll(ctx context.Context, model *ExchangeAccounts) (*ExchangeAccounts, error) {
	builder := squirrel.Insert(d.table).
		PlaceholderFormat(squirrel.Dollar).
		Columns("user_id", "label", "exchange", "api_key", "encrypted_api_secret", "encrypted_passphrase", "config", "is_active", "created_at", "updated_at").
		Values(model.UserID, model.Label, model.Exchange, model.ApiKey, model.EncryptedApiSecret, model.EncryptedPassphrase, model.Config, model.IsActive, model.CreatedAt, model.UpdatedAt)

	updateClause := "ON CONFLICT (id) DO UPDATE SET "
	updateClause += "user_id = EXCLUDED.user_id"
	updateClause += ", "
	updateClause += "label = EXCLUDED.label"
	updateClause += ", "
	updateClause += "exchange = EXCLUDED.exchange"
	updateClause += ", "
	updateClause += "api_key = EXCLUDED.api_key"
	updateClause += ", "
	updateClause += "encrypted_api_secret = EXCLUDED.encrypted_api_secret"
	updateClause += ", "
	updateClause += "encrypted_passphrase = EXCLUDED.encrypted_passphrase"
	updateClause += ", "
	updateClause += "config = EXCLUDED.config"
	updateClause += ", "
	updateClause += "is_active = EXCLUDED.is_active"
	updateClause += ", "
	updateClause += "updated_at = EXCLUDED.updated_at"

	builder = builder.Suffix(updateClause + " RETURNING " + strings.Join(d.columns, ", "))
	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build upsert all query: %w", err)
	}

	var result ExchangeAccounts
	err = d.db.QueryRowCtx(ctx, &result, query, args...)
	if err != nil {
		return nil, fmt.Errorf("upsert all: %w", err)
	}
	return &result, nil
}

// FindByIndex performs a covering index query using only indexed columns.
// Automatically builds WHERE conditions for non-zero fields in the request.
// Returns only indexed columns to enable index-only scans (no table access).
func (d *exchangeAccountsDo) FindByIndex(ctx context.Context, req *ExchangeAccountsIndex) ([]*ExchangeAccountsIndex, error) {
	builder := squirrel.Select().
		From(d.table).
		PlaceholderFormat(squirrel.Dollar)

	// Auto-build WHERE conditions from non-zero fields
	if req.ID != 0 {
		builder = builder.Where(squirrel.Eq{"id": req.ID})
	}

	// Select only indexed columns (enables covering index scan)
	builder = builder.Columns("id")

	query, args, err := builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find by index query: %w", err)
	}
	var results []*ExchangeAccountsIndex
	err = d.db.QueryRowsCtx(ctx, &results, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find by index: %w", err)
	}
	return results, nil
}
