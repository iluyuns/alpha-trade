// Code generated by gpmg. DO NOT EDIT.
// generated_at_utc: 2026-01-18T14:25:30Z
// version: 1.0.0

package query

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/Masterminds/squirrel"
)

// settlements is the query entry point for Settlements
var settlements = newSettlementsQuery()

// newSettlementsQuery creates a new query builder for Settlements
func newSettlementsQuery() *settlementsQuery {
	return &settlementsQuery{
		fieldMap: map[string]Field{
			"id":               settlementsField.ID,
			"trade_id":         settlementsField.TradeID,
			"symbol":           settlementsField.Symbol,
			"market_type":      settlementsField.MarketType,
			"side":             settlementsField.Side,
			"realized_pnl":     settlementsField.RealizedPnl,
			"commission":       settlementsField.Commission,
			"funding_fee":      settlementsField.FundingFee,
			"entry_price":      settlementsField.EntryPrice,
			"exit_price":       settlementsField.ExitPrice,
			"quantity":         settlementsField.Quantity,
			"roi":              settlementsField.Roi,
			"opened_at":        settlementsField.OpenedAt,
			"closed_at":        settlementsField.ClosedAt,
			"duration_seconds": settlementsField.DurationSeconds,
			"metadata":         settlementsField.Metadata,
			"created_at":       settlementsField.CreatedAt,
		},
	}
}

// settlementsQuery is the query builder for Settlements
type settlementsQuery struct {
	db       Executor
	fieldMap map[string]Field
}

// settlementsField provides type-safe field access for Settlements
var settlementsField = struct {
	ID              Int64Field
	TradeID         StringField
	Symbol          StringField
	MarketType      StringField
	Side            StringField
	RealizedPnl     DecimalField
	Commission      DecimalField
	FundingFee      DecimalField
	EntryPrice      DecimalField
	ExitPrice       DecimalField
	Quantity        DecimalField
	Roi             DecimalField
	OpenedAt        TimeField
	ClosedAt        TimeField
	DurationSeconds Int64Field
	Metadata        StringField
	CreatedAt       TimeField
}{
	ID:              Int64Field("id"),
	TradeID:         StringField("trade_id"),
	Symbol:          StringField("symbol"),
	MarketType:      StringField("market_type"),
	Side:            StringField("side"),
	RealizedPnl:     DecimalField("realized_pnl"),
	Commission:      DecimalField("commission"),
	FundingFee:      DecimalField("funding_fee"),
	EntryPrice:      DecimalField("entry_price"),
	ExitPrice:       DecimalField("exit_price"),
	Quantity:        DecimalField("quantity"),
	Roi:             DecimalField("roi"),
	OpenedAt:        TimeField("opened_at"),
	ClosedAt:        TimeField("closed_at"),
	DurationSeconds: Int64Field("duration_seconds"),
	Metadata:        StringField("metadata"),
	CreatedAt:       TimeField("created_at"),
}

// WithDB returns a new query instance with the given database executor
func (q *settlementsQuery) WithDB(db Executor) ISettlementsDo {
	return &settlementsDo{
		db:    db,
		table: "\"public\".\"settlements\"",
		columns: []string{
			"id",
			"trade_id",
			"symbol",
			"market_type",
			"side",
			"realized_pnl",
			"commission",
			"funding_fee",
			"entry_price",
			"exit_price",
			"quantity",
			"roi",
			"opened_at",
			"closed_at",
			"duration_seconds",
			"metadata",
			"created_at",
		},
	}
}

// As creates a table alias for the query
func (q *settlementsQuery) As(alias string) *settlementsQuery {
	return q
}

// ISettlementsDo defines the interface for Settlements data operations
type ISettlementsDo interface {
	// Basic CRUD operations
	Create(ctx context.Context, model *Settlements) (*Settlements, error)
	BatchCreate(ctx context.Context, models []*Settlements) ([]*Settlements, error)
	FindByPK(ctx context.Context, iD int64) (*Settlements, error)
	FindByIndex(ctx context.Context, req *SettlementsIndex) ([]*SettlementsIndex, error)
	UpdateByPK(ctx context.Context, model *Settlements) error
	DeleteByPK(ctx context.Context, iD int64) error
	Upsert(ctx context.Context, model *Settlements) (*Settlements, error)
	UpsertAll(ctx context.Context, model *Settlements) (*Settlements, error)

	// Query builder (type-safe, only accepts fields from this table)
	Where(conds ...WhereCondition) ISettlementsDo
	Select(fields ...Field) ISettlementsDo
	Order(orderBys ...OrderByClause) ISettlementsDo
	Limit(limit int) ISettlementsDo
	Offset(offset int) ISettlementsDo

	// Execution methods
	Find(ctx context.Context) ([]*Settlements, error)
	First(ctx context.Context) (*Settlements, error)
	Count(ctx context.Context) (int64, error)
	Update(ctx context.Context, updates map[string]interface{}) (int64, error)
	Delete(ctx context.Context) (int64, error)

	// Transaction support
	WithDB(db Executor) ISettlementsDo
}

// Ensure settlementsDo implements ISettlementsDo
var _ ISettlementsDo = (*settlementsDo)(nil)

// settlementsDo wraps the query builder with chainable methods
type settlementsDo struct {
	db      Executor
	table   string
	columns []string
	builder squirrel.SelectBuilder

	// Query state
	whereSet  bool
	selectSet bool
	orderSet  bool
	limitSet  bool
	offsetSet bool
}

// WithDB returns a new DO instance with the given database executor (for transactions)
func (d *settlementsDo) WithDB(db Executor) ISettlementsDo {
	return &settlementsDo{
		db:      db,
		table:   d.table,
		columns: d.columns,
	}
}

// Where adds WHERE conditions (chainable)
func (d *settlementsDo) Where(conds ...WhereCondition) ISettlementsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	for _, cond := range conds {
		d.builder = d.builder.Where(cond.ToSqlizer())
	}
	return d
}

// Select specifies which fields to select (chainable)
func (d *settlementsDo) Select(fields ...Field) ISettlementsDo {
	if !d.selectSet {
		if !d.whereSet {
			d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
			d.whereSet = true
		}
		d.selectSet = true
	}
	cols := make([]string, len(fields))
	for i, f := range fields {
		cols[i] = f.ColumnName()
	}
	d.builder = d.builder.Columns(cols...)
	return d
}

// Order adds ORDER BY clause (chainable, type-safe)
// Only accepts OrderByClause from this table's fields (e.g., settlementsField.Age.Desc())
func (d *settlementsDo) Order(orderBys ...OrderByClause) ISettlementsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	orderStrs := make([]string, len(orderBys))
	for i, ob := range orderBys {
		orderStrs[i] = ob.ToSQL()
	}
	d.builder = d.builder.OrderBy(orderStrs...)
	d.orderSet = true
	return d
}

// Limit sets the LIMIT clause (chainable)
func (d *settlementsDo) Limit(limit int) ISettlementsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Limit(uint64(limit))
	d.limitSet = true
	return d
}

// Offset sets the OFFSET clause (chainable)
func (d *settlementsDo) Offset(offset int) ISettlementsDo {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	d.builder = d.builder.Offset(uint64(offset))
	d.offsetSet = true
	return d
}

// Find executes the query and returns all matching records
func (d *settlementsDo) Find(ctx context.Context) ([]*Settlements, error) {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	if !d.selectSet {
		d.builder = d.builder.Columns(d.columns...)
	}

	query, args, err := d.builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build find query: %w", err)
	}

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("execute find: %w", err)
	}
	defer rows.Close()

	var results []*Settlements
	for rows.Next() {
		var result Settlements
		err := rows.Scan(
			&result.ID,
			&result.TradeID,
			&result.Symbol,
			&result.MarketType,
			&result.Side,
			&result.RealizedPnl,
			&result.Commission,
			&result.FundingFee,
			&result.EntryPrice,
			&result.ExitPrice,
			&result.Quantity,
			&result.Roi,
			&result.OpenedAt,
			&result.ClosedAt,
			&result.DurationSeconds,
			&result.Metadata,
			&result.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("scan result: %w", err)
		}
		results = append(results, &result)
	}
	return results, rows.Err()
}

// First executes the query and returns the first matching record
func (d *settlementsDo) First(ctx context.Context) (*Settlements, error) {
	if !d.whereSet {
		d.builder = squirrel.Select().From(d.table).PlaceholderFormat(squirrel.Dollar)
		d.whereSet = true
	}
	if !d.selectSet {
		d.builder = d.builder.Columns(d.columns...)
	}
	d.builder = d.builder.Limit(1)

	query, args, err := d.builder.ToSql()
	if err != nil {
		return nil, fmt.Errorf("build first query: %w", err)
	}

	var result Settlements
	err = d.db.QueryRowContext(ctx, query, args...).Scan(
		&result.ID,
		&result.TradeID,
		&result.Symbol,
		&result.MarketType,
		&result.Side,
		&result.RealizedPnl,
		&result.Commission,
		&result.FundingFee,
		&result.EntryPrice,
		&result.ExitPrice,
		&result.Quantity,
		&result.Roi,
		&result.OpenedAt,
		&result.ClosedAt,
		&result.DurationSeconds,
		&result.Metadata,
		&result.CreatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, ErrRecordNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("execute first: %w", err)
	}
	return &result, nil
}

// Count returns the number of matching records
func (d *settlementsDo) Count(ctx context.Context) (int64, error) {
	countBuilder := squirrel.Select("COUNT(*)").From(d.table).PlaceholderFormat(squirrel.Dollar)

	if d.whereSet {
		// Extract WHERE clauses from existing builder if any
		query, args, err := d.builder.ToSql()
		if err != nil {
			return 0, fmt.Errorf("build count query: %w", err)
		}
		// Parse WHERE clause from the query
		_ = query // TODO: extract WHERE clause properly
		_ = args
	}

	query, args, err := countBuilder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build count query: %w", err)
	}

	var count int64
	err = d.db.QueryRowContext(ctx, query, args...).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("execute count: %w", err)
	}
	return count, nil
}

// Update updates matching records with the given field-value pairs
func (d *settlementsDo) Update(ctx context.Context, updates map[string]interface{}) (int64, error) {
	builder := squirrel.Update(d.table).PlaceholderFormat(squirrel.Dollar)

	for col, val := range updates {
		builder = builder.Set(col, val)
	}

	// TODO: Apply WHERE conditions from d.builder

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build update query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("execute update: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("get rows affected: %w", err)
	}
	return affected, nil
}

// Delete deletes matching records
func (d *settlementsDo) Delete(ctx context.Context) (int64, error) {
	builder := squirrel.Delete(d.table).PlaceholderFormat(squirrel.Dollar)

	// TODO: Apply WHERE conditions from d.builder

	query, args, err := builder.ToSql()
	if err != nil {
		return 0, fmt.Errorf("build delete query: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, fmt.Errorf("execute delete: %w", err)
	}

	affected, err := result.RowsAffected()
	if err != nil {
		return 0, fmt.Errorf("get rows affected: %w", err)
	}
	return affected, nil
}
